import cv2
import threading
import queue
import asyncio
import time
import customtkinter as ctk
from PIL import Image

class Config:
    """Application configuration"""
    FRAME_WIDTH = 640  
    FRAME_HEIGHT = 480
    FPS = 30
    POPUP_WIDTH = 300
    POPUP_HEIGHT = 150
    BUTTON_SIZE = 30
    CODEC = 'mp4v'

class CameraManager:
    def __init__(self):
        self.frame_queue = queue.Queue(maxsize=1)
        self.write_queue = queue.Queue()
        self.recording = False
        self.cap = None

    def start_capture(self):
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            print("Failed to open camera")
            return False
        return True

    def capture_frames(self):
        if not self.start_capture():
            return

        while True:
            ret, frame = self.cap.read()
            if not ret:
                break
                
            frame = cv2.resize(frame, (Config.FRAME_WIDTH, Config.FRAME_HEIGHT))
            frame = cv2.flip(frame, 1)
            
            self._update_display_queue(frame)
            if self.recording:
                self._update_write_queue(frame)
            
            time.sleep(0.001)

        self.cap.release()

    def _update_display_queue(self, frame):
        if self.frame_queue.full():
            try:
                self.frame_queue.get_nowait()
            except queue.Empty:
                pass
        try:
            self.frame_queue.put_nowait(frame)
        except queue.Full:
            pass

    def _update_write_queue(self, frame):
        try:
            self.write_queue.put_nowait(frame)
        except queue.Full:
            pass

class PopupWindow(ctk.CTkToplevel):
    def __init__(self):
        super().__init__()
        self.setup_window()
        self.create_widgets()

    def setup_window(self):
        self.title("Recording Complete")
        self.geometry(f"{Config.POPUP_WIDTH}x{Config.POPUP_HEIGHT}")
        
        x = (self.winfo_screenwidth() - Config.POPUP_WIDTH) // 2
        y = (self.winfo_screenheight() - Config.POPUP_HEIGHT) // 2
        self.geometry(f"{Config.POPUP_WIDTH}x{Config.POPUP_HEIGHT}+{x}+{y}")
        
        self.lift()
        self.attributes("-topmost", True)

    def create_widgets(self):
        self.label = ctk.CTkLabel(
            self, 
            text="Successfully!",
            font=("Arial", 14)
        )
        self.label.pack(pady=20)
        
        self.button = ctk.CTkButton(
            self,
            text="OK",
            command=self.destroy
        )
        self.button.pack(pady=10)
        self.grab_set()

class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.camera_manager = CameraManager()
        self.setup_window()
        self.setup_async()
        self.create_widgets()
        self.start_camera()

    def setup_window(self):
        self.title("Camera Stream")
        self.geometry(f"{Config.FRAME_WIDTH}x{Config.FRAME_HEIGHT+100}")
        
    def setup_async(self):
        self.output_path = None
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.write_task = None
        self.display_task = None
        self.popup_task = None
        self.recording_finished = False

    def create_widgets(self):
        self.setup_frames()
        self.setup_buttons()
        self.setup_asyncio_integration()

    def setup_frames(self):
        self.main_frame = ctk.CTkFrame(self)
        self.main_frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        self.label = ctk.CTkLabel(self.main_frame, text="")
        self.label.pack(pady=5)
        
        self.button_frame = ctk.CTkFrame(self.main_frame)
        self.button_frame.pack(side="bottom", pady=10)

    def setup_buttons(self):
        # Button images
        self.load_button_images()
        
        # Path selection button
        self.path_button = ctk.CTkButton(
            self.button_frame,
            text="",
            image=self.folder_image,
            command=self.select_path,
            width=50,
            height=50
        )
        self.path_button.pack(side="left", padx=20)

        # Start/Stop button
        self.start_button = ctk.CTkButton(
            self.button_frame,
            text="",
            image=self.camera_image,
            command=self.toggle_recording,
            state="disabled",
            width=50,
            height=50
        )
        self.start_button.pack(side="left", padx=20)

    def load_button_images(self):
        self.folder_image = ctk.CTkImage(
            light_image=Image.open("assets/folder.png"),
            size=(Config.BUTTON_SIZE, Config.BUTTON_SIZE)
        )
        self.camera_image = ctk.CTkImage(
            light_image=Image.open("assets/camera.png"),
            size=(Config.BUTTON_SIZE, Config.BUTTON_SIZE)
        )
        self.stop_image = ctk.CTkImage(
            light_image=Image.open("assets/stop.png"),
            size=(Config.BUTTON_SIZE, Config.BUTTON_SIZE)
        )

    def start_camera(self):
        # Start camera stream immediately (as daemon thread)
        capture_thread = threading.Thread(target=self.camera_manager.capture_frames, daemon=True)
        capture_thread.start()

        # Start the display task
        self.display_task = self.loop.create_task(self.update_frame())
        
    def setup_asyncio_integration(self):
        def handle_asyncio():
            self.loop.stop()
            self.loop.run_forever()
            self.after(10, handle_asyncio)
        self.after(10, handle_asyncio)

    async def update_frame(self):
        while True:
            if not self.camera_manager.frame_queue.empty():
                frame = self.camera_manager.frame_queue.get()
                if frame is not None:
                    img = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
                    ctk_img = ctk.CTkImage(
                        light_image=img, dark_image=img, size=(Config.FRAME_WIDTH, Config.FRAME_HEIGHT))
                    self.label.configure(image=ctk_img)
                    self.label.imgtk = ctk_img
                self.camera_manager.frame_queue.task_done()
            await asyncio.sleep(0.03)  # ~30fps

    async def write_frames(self, output_path):
        out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(
            *Config.CODEC), Config.FPS, (Config.FRAME_WIDTH, Config.FRAME_HEIGHT))
        try:
            while True:
                if not self.camera_manager.recording and self.camera_manager.write_queue.empty():
                    break
                try:
                    frame = self.camera_manager.write_queue.get_nowait()
                    if frame is None:
                        break
                    out.write(frame)
                    self.camera_manager.write_queue.task_done()
                except queue.Empty:
                    await asyncio.sleep(0.001)
                    continue
        finally:
            out.release()
            self.recording_finished = True
            self.popup_task = self.loop.create_task(self.show_popup())

    async def show_popup(self):
        await asyncio.sleep(2)  
        self.after(0, lambda: PopupWindow())
        self.recording_finished = False

    def select_path(self):
        self.output_path = ctk.filedialog.asksaveasfilename(
            defaultextension=".mp4",
            filetypes=[("MP4 files", "*.mp4")]
        )
        if self.output_path:
            self.start_button.configure(state="normal")

    def toggle_recording(self):
        if not self.camera_manager.recording:
            # Start recording
            self.camera_manager.recording = True
            self.start_button.configure(image=self.stop_image)
            self.write_task = self.loop.create_task(self.write_frames(self.output_path))
        else:
            # Stop recording
            self.camera_manager.recording = False
            self.start_button.configure(image=self.camera_image)
            while not self.camera_manager.write_queue.empty():
                self.camera_manager.write_queue.get()
            self.camera_manager.write_queue.put(None)

    def on_closing(self):
        # Stop recording if in progress
        if self.camera_manager.recording:
            self.camera_manager.recording = False
            while not self.camera_manager.write_queue.empty():
                self.camera_manager.write_queue.get()
            self.camera_manager.write_queue.put(None)
        
        # Cancel all tasks
        if self.display_task:
            self.display_task.cancel()
        if self.write_task:
            self.write_task.cancel()
        if self.popup_task:
            self.popup_task.cancel()
        
        # Stop the event loop
        self.loop.stop()
        self.quit()

if __name__ == "__main__":
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")

    app = App()
    app.protocol("WM_DELETE_WINDOW", app.on_closing)
    app.mainloop()
    print("App closed")
